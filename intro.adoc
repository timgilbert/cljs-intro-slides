= Intro to ClojureScript
:author:    Tim Gilbert
:source-highlighter: pygments
:backend: slidy
:max-width: 45em
:data-uri:
:icons:

== Agenda
- Lisp Refresher
- Clojure
- ClojureScript
- More ClojureScript
- Questions and Answers

== An Abreviated History of Lisp Dialects
[role="incremental"]
* LISP 1.0, 1958
** LISt Processor, invented by John McCarthy

* Scheme, 1975
** Minimalist, functional variant
** First dialect to implement tail-call optimization

* Common Lisp, 1984
** Unified different dialects into de facto standard

* ANSI Standard Common Lisp, 1994
** CLOS: Common Lisp Object System

* Clojure, 2007
** Functional (emphasis on immutability)
** Tight integration with Java virtual machine
** ClojureScript: Clojure-to-Javascript compiler

== Lisp: Basics

- Basic primitives: numbers, strings, boolean, more
- Top-level items are "forms" (eg, lists input to the repl)
- When a form is evaluated, the first element is a function
  and the rest are arguments

[source,common-lisp]
.Example
------------------------------------------------------
(+ 3 4 5 6)
; => 18
(/ (+ 3 4 5 6) 2)
; => 9
(= 9 (/ (+ 3 4 5 6) 2))
; => T
(= 7 (/ (+ 3 4 5 6) 2))
; => NIL
------------------------------------------------------

== Lisp: List Processing

- The quote macro prevents items from being evaluated
- Various functions exist to operate on lists
- `car` and `cdr` are names derived from

[source,common-lisp]
.Example
------------------------------------------------------
'(1 2 3 4)
; => (1 2 3 4)
(list 1 (+ 1 1) 3 4)
; => (1 2 3 4)
'(1 (+ 1 1) 3 4)
; => '(1 (+ 1 1) 3 4)
(car '(1 2 3 4))
; => 1
(cdr '(1 2 3 4))
; => (2 3 4)
------------------------------------------------------

== Lisp: Functions

- Functions are first-class (can be passed as arguments, etc)
- The usual functional programming suspects exist (`map`, etc)
- Common lisp needs sharp-quote (`#'`) for function quoting
- Lambda expressions exist (and must also be sharp-quoted)

[source,common-lisp]
.Example
------------------------------------------------------
(defun square (x)
  (* x x))
; => SQUARE
(square 4)
; => 9
(mapcar #'square '(1 2 3 4 5))
; => (1 4 9 16 25)
(mapcar #'(lambda (x) (+ x 5))
        '(10 20 30))
; => (15 25 35)
------------------------------------------------------

== Lisp: Recursion

- Lisp includes both functional and imperative constructs
- Lists lend themselves well to recursive processing

[source,common-lisp]
.Example
------------------------------------------------------
(defun sum-list (input)
  (if (null input)
      0
      (+ (car input)
         (sum-list (cdr input)))))
; => SUM-LIST
(sum-list '(3 4 5))
; => 12
(sum-list '())
; => 0
------------------------------------------------------

== Lisp: Macros

== Clojure Basics

- Lisp + sugar + jvm

== ClojureScript

== That's it

Questions?