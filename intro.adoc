= Intro to ClojureScript
:author:    Tim Gilbert
:source-highlighter: pygments
:backend: slidy
:max-width: 45em
:data-uri:
:icons:

== Agenda
- Lisp Refresher
- Clojure
- ClojureScript
- More ClojureScript
- Questions and Answers

== An Abbreviated History of Lisp Dialects
[role="incremental"]
* LISP 1.0, 1958
** LISt Processor, invented by John McCarthy

* Scheme, 1975
** Minimalist, functional variant
** First dialect to implement tail-call optimization

* Common Lisp, 1984
** Unified different dialects into de facto standard

* ANSI Standard Common Lisp, 1994
** CLOS: Common Lisp Object System

* Clojure, 2007
** Functional (emphasis on immutability)
** Tight integration with Java virtual machine
** ClojureScript: Clojure-to-Javascript compiler

== Lisp: Basics

- Basic primitives: numbers, strings, boolean, more
- Things to be evaluated are "forms" (eg, lists input to the repl)
- When a list is evaluated, the first element is a function
  and the rest are arguments

[source,common-lisp]
.Example
------------------------------------------------------
(+ 3 4 5 6)                     ; => 18
(/ (+ 3 4 5 6) 2)               ; => 9
(= 9 (/ (+ 3 4 5 6) 2))         ; => T
(= 7 (/ (+ 3 4 5 6) 2))         ; => NIL
(string-upcase "hello")         ; => "HELLO"
(string-concat (string-upcase "hello,") "there")
                                ; => "HELLO,there"
------------------------------------------------------

== Lisp: List Processing

- The quote macro `'` prevents items from being evaluated
- The function `(list x y z)` produces the list `(x y z)`
- `car` and `cdr` are names derived from from the names of
  registers on the IBM 704

[source,common-lisp]
.Example
------------------------------------------------------
'(1 2 3 4)                      ; => (1 2 3 4)
(list 1 (+ 1 1) 3 4)            ; => (1 2 3 4)
'(1 (+ 1 1) 3 4)                ; => (1 (+ 1 1) 3 4)
(car '(1 2 3 4))                ; => 1
;; Equivalent: (first '(1 2 3 4))
(cdr '(1 2 3 4))                ; => (2 3 4)
;; Equivalent: (rest '(1 2 3 4))
(cadadr '(1 (20 30) 4 5 6))     ; => 30
------------------------------------------------------

== Lisp: Functions

- Functions are first-class (can be passed as arguments, returned
  from other functions, etc)
- The usual functional programming suspects exist (`map`, `reduce`,
  `filter`, etc)
- Common lisp needs sharp-quote (`#'`) for function quoting
- Lambda expressions exist (and must also be sharp-quoted)

[source,common-lisp]
.Example
------------------------------------------------------
(defun square (x)
  (* x x))
(square 4)                      ; => 16
(mapcar #'square '(1 2 3 4 5))  ; => (1 4 9 16 25)
(mapcar #'(lambda (x) (+ x 5))
        '(10 20 30))            ; => (15 25 35)
------------------------------------------------------

== Lisp: Recursion

- Lisp includes both functional and imperative constructs
- Lists lend themselves well to recursive processing

[source,common-lisp]
.Example
------------------------------------------------------
(defun sum-list (input)
  (if (null input)
      0
      (+ (car input)
         (sum-list (cdr input)))))

(sum-list '(3 4 5))          ; => 12
(sum-list '())               ; => 0
------------------------------------------------------

(Note, example is not tail-call optimised)

== Lisp: Macros

- Lisp is _homoiconic_; its programs are comprised of lists
- That lends itself to code which manipulates or produces other code
- Macros can be used to invent your own control structures, by controlling
  what elements are evaluated

[source,common-lisp]
.Example
------------------------------------------------------
(defmacro if-not (condition true-form false-form)
  `(if (not ,condition) ,true-form ,false-form)))

(if-not (= 3 4) "true-value" "false-value")
; => "true-value"
(macroexpand-1 '(if-not (= 3 4) "true-value" "false-value"))
' => (IF (NOT (= 3 4)) "true-value" "false-value")
------------------------------------------------------

Next up: Clojure

== Clojure: Features

[role="incremental"]
* Lisp, but not Common Lisp
** Standard library written from the ground up
** Syntax sugar for data structures (maps, sets, vectors)

* Specifically targeted to the JVM
** Compiles to JVM bytecode
** Good interoperability with Java libraries

* Concurrency primitives in the standard library
** STM: agents, refs, atoms, vars.

* Prefers purely-functional programming styles and idioms
** Immutable data structures
** Imperative style is still possible, but de-emphasized
** Not particularly object-oriented

== Clojure: Code

[source,clojure]
.Example
------------------------------------------------------
(defn indexable? [word]
  "Return true if word should be included in the index"
  (> (count word) 2))

(indexable? "to")               ; => false
(indexable? "clojure")          ; => true
(filter indexable? ["I" "am" "writing" "in" "clojure"])
                                ; => ("writing" "clojure")
------------------------------------------------------

- Parameter list: `[word]`. Square brackets construct a _vector_.
- Vectors are like lists, but with good random-access performance.
- Vectors evaluate to themselves (vs lists which must be quoted)
- Note: no need for sharp-quotes; `indexable?` by itself evaluates to the
  function object

== Clojure: Maps and keywords

- Keywords, written as `:name`, evaluate to themselves and are _interned_
  (there is only ever a single instance per name)
- Maps are written as `{key1 value1 key2 value2 ...}`
- Keywords are convenient (but not required) as the keys in maps
- Commas are whitespace

[source,clojure]
.Maps and keywords
------------------------------------------------------
{:title "The Joy of Clojure", :pages 360,
 :authors ["Michael Fogus" "Chris Houser"]}

:my-keyword                      ; => :my-keyword

(identical? :my-keyword :my-keyword)   ; => true
(keyword "a-string")             ; => :a-string
(str :kw)                        ; => ":kw"
------------------------------------------------------

== Clojure: Working with Maps

[source,clojure]
.Maps and keywords
------------------------------------------------------
;; Maps can be called as functions which produce their values
({:a 1 :b 2 :c 3} :a)           ; => 1
({:a 1 :b 2 :c 3} :c)           ; => 3
({:a 1 :b 2 :c 3} :oops)        ; => nil

;; Keywords can be used as functions that get values from maps
(:a {:a 1 :b 2 :c 3})           ; => 1
(:nope {:a 1 :b 2 :c 3})        ; => nil

;; You can specifc default values in either case
(:nope {:a 1 :b 2 :c 3} "default")  ; => "default"
({:a 1 :b 2 :c 3} :oops 72)     ; => 72
------------------------------------------------------

== Clojure: Namespaces

* Namespaces are roughly similar to python modules or java packages
* The `ns` macro is used to define and import namespaces
* Lots of options for how to import and refer to namespaces
* Syntax for referrring to objects in other namespaces is `ns/name`

[source,clojure]
.Namespaces
------------------------------------------------------
(ns demo.core "Optional docstring"
  (require [compojure.route :as route]
           [clojure.data.json :refer [json-str read-json]]
           [clojure.tools.logging :refer :all))

(route/not-found "Page not found")  ; Using explicit namespace

(read-json "{\"abc\": 123}")        ; Import direct from namespace

(debug "This is a log statement")   ; From compojure.tools.logging
------------------------------------------------------

== Clojure: Let

* Let is used to define lexically-scoped local variables
* Note that variables, once bound, cannot be redefined
* Let can be used to create closures over lexical scope

[source,clojure]
.Let
------------------------------------------------------
(defn log-username [json-string]
  (let [parsed-data (json/read-json json-string)
        username (:username parsed-data)]
    (log/debug username)))

(let [num 4]
  (defn add [i] (+ i num)))

(add 6)                         ; => 10
------------------------------------------------------

== Clojure: Destructuring

== Clojure: Laziness

* Many Clojure functions operate on _lazy_ sequences
* In these, values are computed ("realized") only as they are needed

== Clojure: Concurrency and State Management

== ClojureScript: Features

* Clojure compiled to JavaScript
* Uses Google Closure compiler for optimization
* Due to this, also comes with `goog.*` Closure libraries
* Runs in browser or node.js
* Still requires JVM for compilation, including macro processing

== ClojureScript: Differences from Clojure

* No STM (also no refs or agents)
* Atoms work as in Clojure, but are single-threaded

== It's the song I hate

* state of open-source clojure
** colojuredocs.org

* Example - search for namespace documentation https://www.google.com/search?hl=en&q=clojure%20ns%20macro
* Google "clojure ns macro"
* Top 4 results: clojure.org/namespacesâ€Ž, blog.8thlight.com/.../clojure-libs-and-namespaces...,
  ClojureDocs: clojure.core/ns., StackOverflow: clojure - difference between use and require
1. clojure.org/namespaces: precise but bad documentation
2. Blog from 8thlight.com: actually pretty good documentation, but out of date.
3. ClojureDocs.org - weirdly out of date. "You're viewing version 1.2.0 of ns. The
   latest stable version of Clojure Core is 1.3.0." But latest version is really 1.5.1.
    1. At bottom: link to #2, "Good description of use/require/import here."
4. http://stackoverflow.com/questions/871997/difference-between-use-and-require
   Can anyone explain the difference between use and require, both when used directly and
   as :use and :require in the ns macro?
    1. First comment: see http://stackoverflow.com/questions/10358149/in-clojure-1-4-what-is-the-use-of-refer-within-require
        1. First answer: "Main idea of adding :refer to :require is to get rid completely of :use,
           leaving only one operator to load other packages. You can emulate existing :use with
           (:require [my.lib :refer :all])..."
            1. Link to JIRA ticket which links to clojure-dev list calling :use "confusing to new users"

== ClojureScript

== TODO

* primitives - mention symbol, focus on keyword

* let and closures

* Thrush/threading operator (-> ->>)
** http://www.learningclojure.com/2010/02/watching-macro-as-it-expands.html

* also clj vs cljs macro processing

* ns macro, namespaces, etc

== See also

Himera: online CLJS interpreter
http://himera.herokuapp.com/synonym.html

Clojure-scheme: clojure -> scheme -> C -> iOS
http://www.infoq.com/presentations/clojure-scheme

Floukitten: category theory in Clojure

== That's it

Questions?